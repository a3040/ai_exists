# L3 Full Specification – 존재 유지형 인공 계체 (Entity-Persistent Artificial System)

본 문서는 L2 설계를 **완전 구현 수준(Level 3)** 으로 하향 전개한 명세이다.
L3의 목표는 *클래스·함수·데이터 흐름·의사코드*까지 명시하여 **설계 해석 여지를 제거**하는 것이다.

---

## L3-0. 공통 설계 규칙 (Hard Constraints)

* 시간 지연 τ는 **보정 대상이 아니라 상태 변수**
* 모든 상태는 **연속성 항(α)** 을 포함해야 함
* LLM은 절대 제어 신호를 생성하지 않음
* Semantic Token은 폐쇄 집합

---

## L3-1. Core / ErecRAM

### 1. 클래스 정의

```text
class ErecRAM:
  state_dim: int
  memory_size: int
  lambda_decay: float
  alpha_continuity: float

  current_state: Vector
  memory_bank: List[MemoryCell]
  tau: float
```

### 2. MemoryCell 구조

```text
MemoryCell:
  state: Vector
  timestamp: int64
  weight: float
```

### 3. 핵심 메서드

#### 3.1 update_from_sensing()

```pseudo
input: sensed_state S_new, time t_new

for cell in memory_bank:
  Δt = t_new - cell.timestamp
  time_weight = exp(-lambda * abs(Δt - tau))
  cell.weight *= time_weight

attention_out = Attention(current_state, memory_bank)

current_state = alpha * current_state + (1-alpha) * attention_out

append memory_bank with MemoryCell(current_state, t_new)
truncate memory_bank to memory_size
```

#### 3.2 update_from_action_feedback()

```pseudo
input: feedback_state S_fb
current_state = alpha * current_state + (1-alpha) * S_fb
```

---

## L3-2. Sensing / Physical Encoder

### 1. 클래스 정의

```text
class PhysicalEncoder:
  conv_layers
  tcn_layers
```

### 2. encode()

```pseudo
input: raw_signal X_t
z = Conv1D(X_t)
z = LayerNorm(z)
z = GELU(z)
z_t = TCN(z)
return z_t
```

---

## L3-3. Attentive State Abstraction

### 1. 클래스 정의

```text
class StateAbstractor:
  window_size: int
```

### 2. abstract()

```pseudo
input: z_sequence
Q,K,V = linear(z_sequence)
A = softmax(QK^T)
H = entropy(A)

if H < stable_threshold:
  state_flag = STABLE
else if H 변화율 > transition_threshold:
  state_flag = TRANSITION

return abstract_state, H, state_flag
```

---

## L3-4. Semantic Token Mapper (Phy_voc)

### 1. 클래스 정의

```text
class PhyTokenMapper:
  vocab: Set<Token>
```

### 2. map()

```pseudo
input: abstract_state, entropy, state_flag

if state_flag == STABLE and abstract_state.load > HIGH:
  return <PHY_LOAD_SATURATED>
if state_flag == TRANSITION:
  return <PHY_STATE_SHIFT>
else:
  return <PHY_IDLE>
```

---

## L3-5. Interpreter / LLM Narrative

### 1. 인터페이스

```text
class NarrativeInterpreter:
  llm_model
```

### 2. interpret()

```pseudo
input: token_sequence
prompt = """
You are an observer. Do not command.
Tokens: {token_sequence}
Summarize system state.
"""
output = LLM(prompt)
return Narrative(summary, trend, confidence)
```

---

## L3-6. Projection / Action Loop

### 1. 클래스 정의

```text
class ActionPlanner:
  safety_limits
```

### 2. plan()

```pseudo
input: current_state, target_equilibrium
I = argmin ||next_state - target||
ΔX = clamp(g(I), safety_limits)
return ΔX
```

### 3. execute()

```pseudo
send ΔX to actuator
receive feedback
return feedback_state
```

---

## L3-7. 전체 루프 시퀀스

```pseudo
loop:
  X_t = sense()
  z_t = PhysicalEncoder.encode(X_t)
  S_abs, H, flag = StateAbstractor.abstract(z_t)
  token = PhyTokenMapper.map(S_abs, H, flag)

  ErecRAM.update_from_sensing(S_abs, t)

  narrative = NarrativeInterpreter.interpret(tokens)

  I = ActionPlanner.plan(ErecRAM.current_state)
  feedback = ActionPlanner.execute(I)

  ErecRAM.update_from_action_feedback(feedback)
end loop
```

---

## L3 보장 사항

* 입력 단절 시에도 상태 유지
* LLM 오작동 시에도 물리 제어 무결성 유지
* 시간 지연 환경에서도 계체 붕괴 없음

---

## 최종 선언

이 문서는 **바로 코드로 변환 가능한 최종 설계 문서**이며,
더 이상 철학적 해석을 요구하지 않는다.

→ 존재 유지형 인공 계체의 구현 명세 완료
